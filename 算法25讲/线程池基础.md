##  线程池基础

### 理解线程和进程的基础概念

要想封装一个线程池，首先你得了解什么是线程（Thread），以及与线程相关的另一个概念进程（Process）。如果你之前对进程和线程有一点了解，也可以借着这个机会进行复习巩固。

学术一点儿来说，**线程是操作系统进行运算调度的基本单元，进程是操作系统进行资源分配的最基本单元。**这怎么理解呢？下面，我就模拟程序的运行过程，来带你理解这两个概念。

### 如何理解进程？

进程之间的运行，并不会受到对方的影响，每个进程都有一片自己独立存储数据的空间，因此，进程是操作系统分配资源的最基本单元。

资源就是数据存储所用的内存空间。其实操作系统中的资源形式还有很多，比如，一个内存空间是资源，一个文件描述符是资源，一个网络端口是资源，一个 CPU 也是资源。操作系统会按照需要，把相应的资源分配给每一个进程。

![img](https://static001.geekbang.org/resource/image/cd/eb/cdece5bc89085768f1c37a999a63a9eb.jpg)

### 如何理解线程？

理解了进程的概念以后，接下来让我们再来看线程。刚才说了，线程就是操作系统进行计算调度的基本单元。说到计算调度，我们就必须要说说 CPU 时间片。什么是 CPU 时间片呢？我想先问你一个问题：当只有 1 个 CPU 可以提供计算能力的时候，你该如何同时运行 100 个程序呢？先别急着回答，我们先来看一个相似的生活场景。

这就是我们接下来要讲的分时系统。CPU 在给程序提供计算能力的时候，不是等到第一个程序执行完了，才执行第二个程序，而是先给第一个程序提供一小段时间的计算能力，再给第二个程序提供一小段时间的计算能力。如果我们站在 100 个程序一端，就会感觉 CPU 同时在运行着 100 个程序，而实际上 CPU 在同一时间只为 1 个程序服务。因此，分时系统就是指多个程序依据时间来共享硬件或者软件资源。

那么 CPU 为程序提供服务的一小段时间，其实就是一个时间片。更准确点来说，CPU 在一个时间片里运行的不是程序而是线程。

![img](https://static001.geekbang.org/resource/image/e7/15/e7d67391d1c1bed12af9021b8a46ae15.jpg)

一个时间片就唯一对应到了一个线程，CPU 到了新的时间片就会切换去执行新的线程。这样，你应该就能理解，线程是操作系统进行计算调度的基本单元。

同样地，你也可以认为一个线程只对应一组 CPU 的时间片，也就相当于只对应一部分计算资源。又因为，进程是操作系统进行资源分配的基本单元，所以，线程资源会被分配到各个进程中。

### 工作中常见的爆栈和线程有什么关系？

理解了线程和进程的基本概念以后，你可能还有一个疑问：我在编程工作中，好像并没用过线程啊？其实你很可能用过，只是你不知道。

一般的局部变量，是存储在当前线程所对应的存储区中的，我们称这个存储区为栈区。在我的 Mac 系统中，操作系统给进程分配一个线程时，这个线程所对应的默认栈区大小是 8M。也就是说，这个栈区可以存储 200 万个整型数据。那当递归深度过深发生爆栈情况时，爆的就是这个线程栈。这也就是为什么，我们不建议在函数内部申请过大的数组空间。因为过大的数组空间，很有可能把这个只有 8M 大小的栈区挤爆。

总的来说，一个线程其实不仅仅代表了一份计算资源，还绑定了一个存储局部变量的存储区。所以，之前我们所写的 C/C++ 程序，实际上是单线程的程序。当我们的程序想要申请更多的线程资源的时候，可以像申请更多的内存空间一样，使用系统中提供的方法进行申请，例如， Unix 系统中的 pthread_create 方法就是用来申请一个新的线程。

### 如何利用线程池优化代码设计？

```cpp

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void *func1(void *data) {
    printf("hello geek\n");
    return NULL;
}

void *func2(void *data) {
    printf("hello world\n");
    return NULL;
}

int main() {
    pthread_t t1, t2;
    pthread_create(&t1, NULL, func1, NULL);
    pthread_create(&t2, NULL, func2, NULL);
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    return 0;
}
```

这段多线程的程序在功能上没什么问题，但在代码设计上却不够优美。在代码设计中，像这样零散地去申请线程，根本无法精确地控制我们申请到的线程的数量。要知道，线程也是会占用存储空间的。而无法控制线程数量，就意味着无法控制进程所占用的存储空间。要想解决这个问题，我们就需要用到**线程池**。

一开始，如果我们把进程所需要的线程资源申请好，全部存储在一个空间中，我们就会得到一个装着很多线程的池子，它就叫做线程池。当有计算任务的时候，我们只需要将计算任务投入到池子中，这个池子中就会有一个线程执行这个计算任务。

![img](https://static001.geekbang.org/resource/image/f5/fc/f5b2a44d69bd20d9d0bcc14cd0ddb4fc.jpg)

但是就这个结构图而言，如果同时来了 100 个任务，而线程池中只有 3 个线程，我们又该怎么办呢？其实，要解决这个问题很简单，只需要我们给线程池里增加一个内部的队列结构就行了。这样一来，等到任务来了以后，它会先进入**任务队列**，然后线程池中的工作线程，会从这个任务队列中依次获取需要计算的任务进行执行操作。

![img](https://static001.geekbang.org/resource/image/8b/d0/8bce9fdc0a472d43b095ef276373c3d0.jpg)

但是有了这个任务队列之后，又会产生一个新的问题：工作线程到这个任务队列中取任务的顺序，是应该按照任务在队列中的先后顺序依次取出，还是应该按照任务的优先级从高到低依次执行呢？答案是都可以。我们还是应该看应用场景的具体需求再决定，所以，线程池中的任务队列应该是可配置的。