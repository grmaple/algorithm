## 快速排序

排序算法在工作中最常用，也是学习很多其他算法的前置知识。所以，想要学好数据结构与算法，掌握排序算法是第一步。

今天，我就给你出一道和排序算法有关的题目：假设给你一组无序的数字，让你找到其中排名第 k 位的数字。你会怎么做？

这道题最简单的解决办法，就是利用**选择排序**算法，对这组数字进行排序。选择排序的过程如下图所示：

![image-20200905200839581](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200905200839581.png)

具体来说就是，用选择排序算法将数组中的元素，分成已排序区与待排序区。然后，每一轮从待排序区中选择一个最小值元素，放到已排序区的末尾，也就是待排序区的头部。这样，每一次的选择操作，都会使已排序区的长度增加一位，那经过 n 轮选择操作以后，整个数组就是一个有序数组了。

因此，如果我们想找到排名第 k 位的元素，只需要做 k 次选择操作就可以了。这种做法的时间复杂度是 O(k*n) ，当 k 值接近 n / 2 的时候，时间复杂度就是 O(n^2) 。

接下来讲**快速排序**（Quicksort）算法。

### 理解快速排序算法的核心思想

基础的快速排序算法思想很简单，核心就是一句话：**找到基准值的位置。**

具体的过程分成三步：

- 第一步，选择一个值作为基准值；
- 第二步，找到基准值的位置，并将小于基准值的元素放在基准值的前面，大于基准值的元素放在基准值的后面；
- 第三步，对基准值的左右两侧递归地进行这个过程。

第一步，选择一个值作为基准值。

最简单的选择方法，一定是选择待排序区间的头部元素作为基准值。如下图所示，我们选择 8 作为本轮排序的基准值。

![image-20200905201207038](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200905201207038.png)

确定了本轮操作的基准值以后，快速排序的第二步，就是**将小于基准值的元素放在基准值的前面，将大于基准值的元素放在基准值的后面**。这一步通常被叫做 partition 操作，中文直译过来就是分割操作，也就是用基准值将原数组分割成前后两部分。

partition 操作简单来说，就是**空出一个位置，反复地前后调换元素。**这该怎么理解呢？首先，你要理解一点，当我们选择了基准值以后，原先基准值的位置就相当于被空出来了，也就是说数组的第一位是空着的。

![image-20200905201326079](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200905201326079.png)

如果第一位是空的，那我们借助这个空位，将后面小于基准值的元素放到前面的空位上，这样后面就空出一位了。然后，我们再将前面大于基准值的元素放到后面这个空位上。就这样交替进行，直到空位前面的值都小于基准值，空位后面的值都大于基准值为止。过程如下图所示：

![image-20200905201454769](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200905201454769.png)

**快速排序的第三步，是对基准值的左右两侧，递归地进行第一步和第二步。**

也就是说，我们要分别对 6、3、7、2 和 10、9、12 这两部分，再做选择基准值、找基准值位置和递归这三步。由于每次 partition 操作中，我们都会确定一个值，也就是基准值的正确位置，所以，经过有限次递归操作以后，整个数组也就变成了一个有序数组。

### 分析快速排序的时间复杂度

看完了快速排序的算法过程，我们再来分析一下快速排序的时间复杂度。

先来分析 partition 操作这一步的时间复杂度。在 partition 操作的过程中，头指针会循环扫描到基准值最后放置的位置，尾指针也会扫描到最后基准值放置的位置。这样，头尾指针扫描加在一起，其实相当于扫描了整个待排序数组的区域。因此，我们就能得出单次 partition 操作的时间复杂度为 O(n)。也就是说，当前数组区间中有 10 个元素时，我们大概操作 10 次就能找到基准值的位置了。清楚了单次操作的时间复杂度以后，我们就能知道总体的时间复杂度了。

首先，我们要确定总体时间复杂度的公式。我们用 T(n)表示对 n个元素的数组进行快速排序所用的时间，那么 T(n) 中应该包括了单次的 partition 操作用时，以及 parition 操作以后，我们对左右两个子数组分别做快速排序所用的时间，也就是 T(n) = n + T(L) + T(R)。其中 n是单次 partition 操作的用时，T(L)和 T(R)分别是对左右区间进行快速排序的用时，L 和 R分别代表左区间和右区间中元素的数量。

![image-20200905202116202](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200905202116202.png)

接着，我们借助二叉树的结构来求一下 T(n) 。首先，我们可以将基准值看成是由 n 个元素组成的二叉树的根节点，那么 partition 操作就是找到这个根节点的正确位置，总用时就是 n。如果我们将这个用时 n 当做二叉树根节点的独立用时，那么左子树根节点的独立用时就是 L，右子树根节点的独立用时就是 R。这样，我们就得到了这个二叉树第二层上所有节点的独立用时：L + R = n - 1。我们可以将这个值大致看成是 n。依照此方法，你会得到接下来各层二叉树节点的独立用时，关系如图所示：

![image-20200905202242832](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200905202242832.png)

其中，每个节点上的数值代表了这个节点的独立用时。 n = L + R + 1，L = LL + LR + 1， R = RL + RR + 1。这也就意味着，第一层上节点的独立用时总和是 n，第二层上节点的独立用时总和是 L + R = n - 1，第三层上节点的独立用时总和是 LL + LR + RL + RR = n - 3。

其实，如果 n 足够大，那每一层上的所有节点的独立用时总和，我们都可以让其约等于 n。那快速排序的总用时，就可以约等于 n 乘上树的层数，也就是树的高度。因此，这棵树的高度越低，快速排序的效率越好，而树的高度越高，快速排序的效率也就越差。这样一来，我们就让树高这个直观的量和快速排序的效率有了概念上的关联。因此，我们只需要分析树高，就能分析清楚快速排序的执行效率了。

那针对有 n 个节点的二叉树（每个节点代表一个基准值，n 个节点就代表确定了 n 个基准值的位置），我们该怎么确定树高的范围呢？稍微一分析，你会发现，树高最低是 log\_{2}{n} ，也就是每个节点的左右两棵子树，所包含节点数量都差不多。这就意味着，**我们每次选择基准值的时候，都要尽可能选择处在待排序数组中间的数字**。也只有这样，快速排序算法才会达到最好的时间复杂度，也就是 O(nlog_{2}{n})。

结合二叉树的结构，我们分析了快速排序的最好时间复杂度。而快速排序的最坏时间复杂度是 O(n^2)(树高最高为n) 。从中你就能体会到：**数据结构的价值，在于其思维逻辑结构层面的价值。**

那现在，你再想想课程一开始给你出的那道题，是不是很容易就能解出来了？过程很简单，我就不细说了，不过，你可以想想使用快速排序解决这个问题的时间复杂度是什么样的。

在这里，我希望你记住两件事情。

第一，**理解 partition 操作，是理解快速排序算法的关键。**

第二，**想要理解快排的时间复杂度，最有效的途径就是掌握二叉树分析法。**

快速排序算法是什么？用最简洁的语言描述出来。

快速排序有三步，第一步是找基准值，第二步是partition操作，第三步是对partition后产生的两个子序列再次进行一二步。所以难点是一二步。找基准值当然是找中间值最好，但是我们为了便于理解，我们可以先把基准值设为第一个数。然后就是进行partition操作，我们想象第一个数的位置是空的，可以从后面的数里面找数放进来。我们先设立两个指针，一个是尾指针指向最后一个元素，头指针指向第二个元素(第一个元素是基准值不用比较)。然后我们让尾指针和基准值比较，如果比基准值大就向前移动指针，一直到找到比基准值小的数，我们就把它和第一个数换位置(也就是和基准值换位置，因为我们是从小到大排序，这样就把小的放前面了)然后向前移动指针。然后移动头指针，和尾指针作相反的操作，头指针一直找到比基准值大的数，然后和基准值进行交换(此时基准值在后面，交换后，就是大的放在后面了)，如此头尾指针交替执行，一直到他们相遇，结束partition。

```cpp
//quick_sort.cpp
void quick_sort_v1(int *arr, int l, int r) {
    if (l >= r) return ;
    //选择基准值z
    int x = l, y = r, z = arr[l];
    //partition过程
    while (x < y) {
        //移动尾指针，找到一个小于基准值的元素arr[y]
        while (x < y && arr[y] >= z) --y;
        if (x < y) arr[x++] = arr[y];
        //移动头指针，找到一个大于基准值的元素arr[x]
        while (x < y && arr[x] <= z) ++x;
        if (x < y) arr[y--] = arr[x];
    }
    //头尾指针重合，这个位置就是基准值应该放的位置
    arr[x] = z;
    //递归排序
    quick_sort_v1(arr, l, x - 1);
    quick_sort_v1(arr, x + 1, r);
    return ;
}
```

