## 字符串

### 介绍

**1.广泛性**

字符串可以看作字符类型的数字与数组排序、差找、调整有关

很多其他类型的面试题可以看作字符串类型的面试题

**2.概念**

回文

子串（连续）

子序列（不连续）

前缀树（Trie树）

后缀树和后缀数组

匹配

字典序

**3.操作**

增删查改

字符的替换

字符串的旋转

**4.字符串题目常见类型**

（1）规则判断

判断字符串是否符合整数规则

判断字符串是否符合回文字符串规则

（2）数字运算

整数范围有限，需要用字符串实现大整数

（3）和数组操作有关

数组有关的调整、排序

快速排序的划分过程

（4）字符计数

哈希表

固定长度的数组C/C++（256长度）

滑动窗口、寻找无重复字符字串，计算变形词

（5）动态规划

最长公共子串

最长回文子串

（6）搜索类型

宽度优先搜索

深度优先搜索

（7）高级算法与数据结构

Manacher(马拉车)算法解决最长回文子串问题

KMP算法解决字符串匹配问题

前缀树结构

后缀树和后缀数组

通常很少出现

### 例子

**1.给定彼此独立的两棵树头节点分别为t1和t2，判断t1中是否有与t2树拓扑结构完全相同的子树**

普通解法：二叉树遍历+匹配

时间O(nm)

最优解：二叉树序列化+KMP算法

时间O(n+m)

先将两棵树序列化，问题转换成判断str1中是否含义str2，使用KMP算法

**2.给定两个字符串str1和str2，如果str1和str2中出现的字符种类一样且每种字符出现的次数也一样，那么str1和str2互为变形词**

使用哈希表做字符计数，对比两个哈希表的记录是否一样

也可以用固定长度的数组代替哈希表

时间O(n)，额外空间O(n)

**3.如果一个字符串str，把字符串str前面任意部分挪到后面去形成的字符串叫做str的旋转词，判断str1和str2是否互为旋转词**

时间O(n)

1.判断str1和str2是否长度相等

2.生成str1+str1的大字符串

3.用KMP算法判断大字符串是否含有str2

**4.给定字符串str，在单词间作逆序调整**

1.实现将字符串局部所有字符逆序的函数f

2.先用f对字符串所有字符逆序

pig loves dog -> god sevol gip

3.找到逆序后的字符串中每个单词的区域，再用f对每个单词的区域进行逆序

god sevol gip->  dog loves pig

**5.给定一个str，和i。将str[:i]移到右侧，str[i+1:]移到左侧，时间为O(n)，额外空间O(1)**

1.先用f对字符串str[:i]逆序

abcd ->bacd

2.再用f对字符串str[i+1:]逆序

bacd->badc

3.再用f对字符串str整体逆序

badc->cdab

**6.给定一个字符串类型的数组strs，请找到一种拼接顺序，使得将所有字符串拼接起来组成的大字符串是所有可能性中字典序最小的，并返回这个大字符串**

 时间O(nlogn)，其实质是一种排序的实现

str1+str2 < str2+str1 则str1在前面，否则，str2在前面

**7.给定字符串str，将其中所有空格字符替换成“%20”，假设str后面有足够的空间**

对于“a b c”

遍历str，得到空格数量为2

计算长度为5+2*2=9

所以在下标为8的位置开始拷贝，遇到c，放入c，遇到空格，放入%20

**8.给定字符串str，返回str最长无重复字符子串的长度**

时间O(n)，额外空间O(n)

求出以str中每个字符结尾的情况下，最长无重复字符子串的长度，并在其中找出最大值返回

1.在遍历str之前，先申请几个变量。

哈希表 map，key表示某个字符，value为这个字符最近一次出现的位置。

整型变量pre,如果当前遍历到字符str[i],pre表示必须以str[i - 1]字符结尾的情况下，最长无重复子串开始位置的下标，初始时pre = -1。

整型变量len,记录最长无重复子串长度的最大值，初始时，len = 0。

从左到右遍历字符串str,假设现在遍历到str[i],接下来求必须以str[i]结尾的情况下，最长无重复子串的长度。

2.map(str[i])的值表示之前遍历中最近一次出现str[i]的位置，其后一位设为A位置。

3.根据pre的定义，pre  表示以str[i - 1]字符结尾的情况下，最长无重复子串开始的位置，设为B位置。

4.如果pre的位置在A的左边，所以以str[i]结尾的最长无重复子串就是str[a...i]。

![image-20200727220714074](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200727220714074.png)

如果pre的位置在a的右边，以str[i-1]结尾的最长无重复子串是向左扩充到pre结束的。所以以str[i]结尾的最长无重复子串扩充到pre也会停止,所以以str[i]结尾的最长无重复子串就是str[pre...i]

![image-20200727220727720](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200727220727720.png)

5.计算完长度后，B位置和A位置哪一个在右边哪一个就作为新的pre值。然后计算下一个pre的值。所有长度的最大值用len记录
