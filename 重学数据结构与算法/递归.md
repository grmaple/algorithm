## 递归

### 汉诺塔问题

我们的原问题是，把从小到大的 n 个盘子，从 x 移动到 z。

我们可以将这个大问题拆解为以下 3 个小问题：

把从小到大的 n-1 个盘子，从 x 移动到 y；

接着把最大的一个盘子，从 x 移动到 z；

再把从小到大的 n-1 个盘子，从 y 移动到 z。

首先，我们来判断它是否满足**递归的第一个条件。** 其中，第 1 和第 3 个问题就是汉诺塔问题。这样我们就完成了一次把大问题缩小为完全一样的小规模问题。我们已经定义好了递归体，也就是满足来递归的第一个条件。

接下来我们来看判断它是否满足终止条件。随着递归体不断缩小范围，汉诺塔问题由原来“移动从小到大的 n 个盘子”，缩小为“移动从小到大的 n-1 个盘子”，直到缩小为“移动从小到大的 1 个盘子”。移动从小到大的 1 个盘子，就是移动最小的那个盘子。根据规则可以发现，最小的盘子是可以自由移动的。因此，**递归的第二个条件**，终止条件，也是满足的。

经过仔细分析可见，汉诺塔问题是完全可以用递归实现的。我们定义汉诺塔的递归函数为 hanio()。这个函数的输入参数包括了：

3 根柱子的标记 x、y、z；

待移动的盘子数量 n。

具体代码如下所示，在代码中，hanio(n, x, y, z)，代表了把 n 个盘子由 x 移动到 z。根据分析，我们知道递归体包含 3 个步骤：

把从小到大的 n-1 个盘子从 x 移动到 y，那么代码就是 hanio(n-1, x, z, y)；

再把最大的一个盘子从 x 移动到 z，那么直接完成一次移动的动作就可以了；

再把从小到大的 n-1 个盘子从 y 移动到 z，那么代码就是 hanio(n-1, y, x, z)。对于终止条件则需要判断 n 的大小。如果 n 等于 1，那么同样直接移动就可以了。

```java
public static void main(String[] args) {
    String x = "x";
    String y = "y";
    String z = "z";
    hanio(3, x, y, z);
}
public void hanio(int n, String x, String y, String z) {
    if (n < 1) {
        System.out.println("汉诺塔的层数不能小于1");
    } else if (n == 1) {
        System.out.println("移动: " + x + " -> " + z);
        return;
    } else {
        hanio(n - 1, x, z, y);
        System.out.println("移动: " + x + " -> " + z);
        hanio(n - 1, y, x, z);
    }
}
```

抛开用于处理输入异常的代码部分不谈，它的代码包含了 2 个部分：

1.终止条件，即如何处理小规模的问题，实现的代码量一定是很少的；

2.递归体，即大问题向小问题分解的过程，实现的代码量也不会太多。

因此，一个复杂问题的递归实现，通常代码量都不会很多

### 递归需要警惕堆栈溢出

### 递归需要警惕重复计算

### 递归都可以改写成非递归循环形式