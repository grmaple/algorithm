## 算法思维训练

解决代码问题的方法论，宏观上，它可以分为以下 4 个步骤：

- 复杂度分析。估算问题中复杂度的上限和下限。

- 定位问题。根据问题类型，确定采用何种算法思维。

- 数据操作分析。根据增、删、查和数据顺序关系去选择合适的数据结构，利用空间换取时间。

- 编码实现。

### 例题 1：斐波那契数列

斐波那契数列是：0，1，1，2，3，5，8，13，21，34，55，89，144……。你会发现，这个数列中元素的性质是，某个数等于它前面两个数的和；也就是 a[n+2] = a[n+1] + a[n]。至于起始两个元素，则分别为 0 和 1。在这个数列中的数字，就被称为斐波那契数。

【题目】写一个函数，输入 x，输出斐波那契数列中第 x 位的元素。例如，输入 4，输出 2；输入 9，输出 21。要求：需要用递归的方式来实现。

【解析】

**首先我们还是先做好复杂度的分析**

题目中要求要用递归的方式来实现，而递归的次数与 x 的具体数值有非常强的关系。因此，此时的时间复杂度应该是关于输入变量 x 的数值大小的函数。

**至于问题定位**

因为题目中已经明确了要采用递归去解决。所以也不用再去做额外的分析和判断了。

那么，如何使用递归呢？我们需要依赖斐波那契数列的重要性质“某个数等于它前面两个数的和”。也就是说，要求出某个位置 x 的数字，需要先求出 x-1 的位置是多少和 x-2 的位置是多少。递归同时还需要终止条件，对应于斐波那契数列的性质，就是起始两个元素，分别为 0 和 1。

**数据操作方面**

斐波那契数列需要对数字进行求和。而且所有的计算，都是依赖最原始的 0 和 1 进行。因此，这道题是不需要设计什么复杂的数据结构的。

**最后，实现代码**

```java
public static void main(String[] args) {
    int x = 20;
    System.out.println(fun(x));
}
private static int fun(int n) {
    if (n == 1) {
        return 0;
    }
    if (n == 2) {
        return 1;
    }
    return fun(n - 1) + fun(n - 2);
}

```

### 例题2：判断一个数组中是否存在某个数

【题目】给定一个经过任意位数的旋转后的排序数组，判断某个数是否在里面。

例如，对于一个给定数组 {4, 5, 6, 7, 0, 1, 2}，它是将一个有序数组的前三位旋转地放在了数组末尾。假设输入的 target 等于 0，则输出答案是 4，即 0 所在的位置下标是 4。如果输入 3，则返回 -1。

【解析】

**先做复杂度分析**

这个问题就是判断某个数字是否在数组中，因此，复杂度极限就是全部遍历地去查找，也就是 O(n) 的复杂度。

**接着，进入定位问题的环节中**

这个问题有很多关键字，因此能够让你立马锁定问题。例如，判断某个数是否在数组里面，这就是一个查找问题。

**然后，我们来做数据操作分析**

原数组是经过某些处理的排序数组，也就是说原数组是有序的。有序和查找，你就会很快地想到，这个问题极有可能用二分查找的方式去解决，时间复杂度是 O(logn)，相比上面 O(n) 的基线也是有显著的提高。

在利用二分查找时，更多的是判断，基本没有数据的增删操作，因此不需要太多地定义复杂的数据结构。

分析到这里，解决方案已经非常明朗了，就是采用二分查找的方法，在 O(logn) 的时间复杂度下去解决这个问题。二分查找可以通过递归来实现。而每次递归的关键点在于，根据切分的点（最中间的那个数字），确定是向左走还是向右走。这也是这个例题中唯一的难点了。

试想一下，在一个旋转后的有序数组中，利用中间元素作为切分点得到的两个子数组有什么样的性质。经过枚举不难发现，这两个子数组中，一定存在一个数组是有序的。也可能出现一个极端情况，二者都是有序的。如下图所示：

![image-20200728141128351](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200728141128351.png)

对于有序的一边，我们是很容易判断目标值，是否在这个区间内的。如果在其中，也说明了目标值不在另一边的旋转有序组里；反之亦然。

当我们知道了目标值在左右哪边之后，就可以递归地调用旋转有序的二分查找了。之所以可以递归调用，是因为，对于旋转有序组，这个问题和原始问题完全一致，可以调用。对于有序组，它是旋转有序的特殊情况（即旋转 0 位），也一定是可以通过递归的方法去实现查找的。直到不断二分后，搜索空间只有 1 位数字，直接判断是否找到即可。

**最后，实现代码**

```java
public static void main(String[] args) {
    int[] arr = { 4, 5, 6, 7, 0, 1, 2 };
    int target = 7;
    System.out.println(bs(arr, target, 0, arr.length-1));
}
private static int bs(int[] arr, int target, int begin, int end) {
    //终止条件
    if (begin == end) {
        //判断最后剩下的 1 个元素是否与 target 相等：
        if (target == arr[begin]){
            return begin;
        }
        else{
            return -1;
        }
    }
    int middle = (begin + end)/2;
    //如果相等，则查找到结果并返回；
    if (target == arr[middle]) {
        return middle;
    }
    //左边有序
    if (arr[begin] <= arr[middle-1]){
        //目标值在左边
        if (arr[begin] <= target && target <= arr[middle-1]) {
            return bs(arr,target, begin,middle-1);
        }
        //目标值在右边
        else {
            return bs(arr,target, middle+1,end);
        }
    }
    //右边有序
    else {
        //目标值在右边
        if (arr[middle+1] <= target && target <= arr[end]) {
            return bs(arr,target, middle+1,end);
        }
        //目标值在左边
        else {
            return bs(arr,target, begin,middle-1);
        }
    }
}

```

### 例题3：求解最大公共子串

【题目】输入两个字符串，用动态规划的方法，求解出最大公共子串。

例如，输入 a = "13452439"， b = "123456"。由于字符串"345"同时在 a 和 b 中出现，且是同时出现在 a 和 b 中的最长的子串。因此输出"345"。

【解析】

这里已经定义了问题，就是寻找最大公共子串。同时也定义了方法，就是要用动态规划的方法。那么我们也不需要做太多的分析，只要依赖动态规划的步骤完成就可以了。

动态规划的基本方法是：分阶段、找状态、做决策、状态转移方程、定目标、寻找终止条件。

- 对于一个可能的起点，它后面的每个字符都是一个阶段。

- 状态就是当前寻找到的相匹配的字符。

- 决策就是当前找到的字符是否相等（相等则进入到公共子串中）。

- 状态转移方程可以写作 sk+1 = uk(sk)。可以理解为，如果 sk = "123"是公共子串，且在 a 字符串和 b 字符串中，"123"后面的字符相等，假设为"4"，则决策要进入到公共子串中，sk+1 = "1234"。

- 目标自然就是公共子串最长。

- 终止条件就是决策到了不相等的结果。

对于输入的图，采用什么样的数据结构予以保存。最终我们选择了二维数组。每一行或每一列就对应了输入字符串 a 和 b 的每个字符，即 6 x 8 的二维数组（矩阵）为：

![image-20200728142027481](C:\Users\xuyingfeng\AppData\Roaming\Typora\typora-user-images\image-20200728142027481.png)

最终，检索这个矩阵，得到的最大数字就是最大公共子串的长度。根据其所在的位置，就能从 a 或 b 中找到最大公共子串。

```java
public static void main(String[] args) {
    String a = "13452439";
    String b = "123456";
    getCommenStr(a, b);
}
public static void getCommenStr(String a, String b) {
    char[] c1 = a.toCharArray();
    char[] c2 = b.toCharArray();
    int[][] m = new int[c2.length+1][c1.length+1];
    for (int i = 1; i <= c2.length; i++) {
        for (int j = 1; j <= c1.length; j++) {
            if (c2[i - 1] == c1[j - 1])
                m[i][j] = m[i - 1][j - 1] + 1;
        }
    }
    int max = 0;
    int index = 0;
    for (int i = 0; i <= c2.length; i++) {
        for (int j = 0; j <= c1.length; j++) {
            if (m[i][j] > max) {
                max = m[i][j];
                index = i;
            }
        }
    }
    String s = "";
    for (int i = index - max; i < index; i++)
        s += b.charAt(i);
    System.out.println(s);
}

```

