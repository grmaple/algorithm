### 48不用加减乘除做加法

##### 题目

写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。

##### 解法

使用^来表示相加后结果，因为1+1 = 0，1+0 = 1， 0+0 = 0，^可以实现

使用&来表示相加后进位，因为1+1 = 1，1+0 = 0， 0+0 = 0，&可以实现

进位后需要左移一位，然后结果和进位再次相加

例如5+7,即101+111

101^111=010

101&111=101 然后左移一位，变成1010

010^1010=1000

010&1010=0010然后左移一位，变成100

1000^100=1100

1000&100=0,跳出循环，结果为1100



由于python长整数类型可以表示无限位，所以需要人为设置边界，避免死循环。所以需要& 0xFFFFFFFF

返回值，怎么判断是正数还是负数?

比0x7FFFFFFF小的是正数

比#0x7FFFFFFF大的是负数(补码形式)



明白了

一直以为~(num1^0xFFFFFFFF)，是对自身取反了然后再取反，就以为可以不用这样做了，原来这里大有深意

用个简单的例子就明白了。

对于一个4位的系统。0001=1，0111=7，1000=-8，1001=-7，1111=-1

然而我们认为4位太长了，所以使用2位来截断。

00=0，01=1，10=-2，11=-1

现在有个num=1，需要截断它，通过0001&11 = 0001，这时我们把1(0001)就认为是1(01)了，然后当作正数直接输出，这样还没错。

可是如果是一个num=7，通过0111&11 = 0011，这时我们把7(0111)就认为是-1(11)了。所以需要有个还原操作。

0011^0011=0000，然后使用~0000，得到1111，也即-1.



我们看到的就是2位系统的结果。比如我们现在看到了一个-1(11)，然后如果直接输出，那么结果可能是7(0111)。这时我们需要使用还原操作。

0011^0011=0100，然后使用~0000，得到1111，也即-1.

num1出来的时候。已经是通过num1 & 0xFFFFFFFF，所以它的前面的已经都清零了。



~(num1^0xFFFFFFFF)这个式子的关键是。后面32位进行异或取反，前面的还是原来的不变。然后再对整体进行按位取反。



```python
# -*- coding:utf-8 -*-
class Solution:
    def Add(self, num1, num2):
        # write code here
        while num2:
            tmp = (num1 ^ num2) & 0xFFFFFFFF
            num2 = ((num1 & num2) << 1) & 0xFFFFFFFF
            num1 = tmp
            #0x7FFFFFFF为32位最大正数
        return num1 if num1<=0x7FFFFFFF else ~(num1^0xFFFFFFFF)
    	#return num1 if num1<=0x7FFFFFFF else num1 -0x100000000
```

