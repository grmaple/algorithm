## 排序

### 介绍

##### 简单排序

比较思想

冒泡排序：时间O(n^2)，空间O(1)，稳定

选择排序：时间O(n^2)，空间O(1)，不稳定

插入排序：时间O(n^2)，空间O(1)，稳定

归并排序：时间O(nlogn)，空间O(n)，稳定

快速排序：时间O(nlogn)，空间O(logn)-O(n)，不稳定

堆排序：时间O(nlogn)，空间O(1)-O(logn)(递归调用栈)，不稳定

希尔排序：时间O(nlogn)，空间O(1)，不稳定

##### 其他排序

桶排序思想，桶数量m，用于不平均的小数据

计数排序：时间O(n)，空间O(m)，稳定

基数排序：时间O(n)，空间O(m)，稳定

### 例子

**1.已知一个几乎有序的数据（如果把数组排好序，每个元素移动的距离不超过k，k相对于数组长度来说很小），选择什么排序?**

时间O(n)中，基数和计数不适用于使用情况

时间O(n^2)中，冒泡和选择，和数组原始序列无关

插入排序和数组原始序列有关，时间为O(nk)

时间O(nlogn)中，快速和归并，和数组原始序列无关

答案是使用改进后的堆排序

使用前k个数创建小根堆，弹出最小值后，向后移动，然后进行调整

时间为O(nlogk)

**2.判断数组中是否有重复值。必须保证额外空间复杂度为O(1)**

如果没有空间复杂度限制，就用哈希表，时间O(n)，空间O(n)

有限制，就要先排序再判断

答案是使用非递归版本的堆排序

**3.把两个有序数组合并成为一个数组，第一个数组的空间正好可以容纳两个数组元素**

需要从后往前覆盖

**4.荷兰国旗问题。只包含0，1，2的整数数组进行排序，要求用交换、原地排序，而不是用计数进行排序**

和快排类似

时间O(nlogn)，额外空间O(1)

数组前设立0区和数组后设立2区。指针遇到1就向后移动，遇到0就和0区后一个数交换，然后0区增长，指针后移。遇到2就和2区前一个数交换，然后2区增长，指针不动（因为来的数还要再次判断）。

**5.在行列都排好序的矩阵中找数**

**0 1 2 5**

**2 3 4 7**

**4 4 4 8**

**5 7 7 9**

**如果k为7，返回true，如果k为6，返回false**

从右上角开始寻找

如果当前数比k小，则向下移动，

如果当前数比k大，则向左移动

矩阵大小n*m，则时间O(n+m)

**6.需要排序的最短子数组长度，如[1，5，4，3，2，6，7]**

**返回4，因为只有[5，4，3，2]需要排序**

时间O(n)，额外空间O(1)

从左到右遍历数组，用max记录最大值，关注当前值<最大值的情况，记录最右位置

从右往左遍历数组，用min记录最小值，关注当前值>最小值的情况，记录最左位置

(最左位置-最右位置)+1就是结果

**7,给定一个无序数组，返回排序后相邻两数最大差值。**

**如 1，2，3，4，7，8，9返回7-4=3**

时间O(n)，额外空间O(n)

思想来自桶排序

对7，9，3，4，2，1

先找到最小值1和最大值9。然后把[1,9)分成7个等量桶，增加个最大值桶，然后分别进入桶。

n个数进入n+1个桶，则必然会产生空桶。

不用考虑同一个桶的相邻数，只用考虑桶间的相邻数

使用每个桶的最小值减去前一个桶的最大值，然后找到最大差值